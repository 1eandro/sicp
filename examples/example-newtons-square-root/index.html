<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.80.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Example: Square roots by Newton&#39;s Method &middot; Ben&#39;s Solutions to Sicp</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://benjamin-philip.github.io/sicp/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://benjamin-philip.github.io/sicp/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://benjamin-philip.github.io/sicp/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://benjamin-philip.github.io/sicp/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
<script>
 document.addEventListener("DOMContentLoaded", function() {
     renderMathInElement(document.body, {
         
         
         delimiters: [
             {left: '$$', right: '$$', display: true},
             {left: '$', right: '$', display: false},
             {left: '\\(', right: '\\)', display: false},
             {left: '\\[', right: '\\]', display: true}
         ],
         
         throwOnError : false
     });
 });
</script>


</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://benjamin-philip.github.io/sicp/"><h1>Ben&#39;s Solutions to Sicp</h1></a>
      <p class="lead">
       My journey reading Sicp: From learning scheme to building an interpreter. 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://benjamin-philip.github.io/sicp/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

      <main class="content container">
          <div class="post">
  <h1>Example: Square roots by Newton&#39;s Method</h1>
  <time datetime=2020-10-20T00:00:00Z class="post-date">Tue, Oct 20, 2020</time>
  <p>All the Procedures explained previously were much like
ordinary Mathematical functions. However in Mathematics,
we are usually concerned with declarative (what is) descriptions.
We soon reach issues when deriving procedure from their
Mathematical definition. Consider the definition of the
Square root:</p>
<p>$ \sqrt{x} = $ the <em>y</em> such that $ y \geq 0 $ and $ ^{2} = x $</p>
<p>The above is a perfectly legitimate mathematical function <strong>BUT</strong> doesn&rsquo;t
tell use <em>how</em> to compute the sqrt.</p>
<h1 id="computing-square-roots">Computing Square Roots</h1>
<p>So how does one compute square roots ? Of the many methods,
the most prominent of these is Newton&rsquo;s Method. The main idea
is that we can get a better a guess of the square root of number <code>x</code>
with the guess <code>x</code> by:</p>
<ol>
<li>Taking the Quotient of x/y</li>
<li>and assigning <code>x</code> to the average of the <code>Quotient</code> and <code>x</code></li>
</ol>
<p>So For example the sqrt of <code>2</code> with the guess <code>1</code>:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Guess</th>
<th style="text-align:left">Quotient</th>
<th style="text-align:left">Average</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">(2/1) = 2</td>
<td style="text-align:left">((2 + 1)/2) = 1.5</td>
</tr>
<tr>
<td style="text-align:left">1.5</td>
<td style="text-align:left">(2/1.5) = 1.3333</td>
<td style="text-align:left">((1.3333 + 1.5)/2) = 1.4167</td>
</tr>
<tr>
<td style="text-align:left">1.4167</td>
<td style="text-align:left">(2/1.4167) = 1.4118</td>
<td style="text-align:left">((1.4167 + 1.4118)/2) = 1.4142</td>
</tr>
<tr>
<td style="text-align:left">1.4167</td>
<td style="text-align:left">,,,</td>
<td style="text-align:left">&hellip;</td>
</tr>
</tbody>
</table>
<h1 id="writing-a-scheme-procedure">Writing a scheme procedure</h1>
<p>Continuing with this process, we obtain better and better approximations of the square root.
However we must have a test to check to accuracy of the root so as to stop the process at a
certain accuracy and prevent a hit on the recursion limit.</p>
<h2 id="the-iterative-process">The Iterative process</h2>
<p>Let&rsquo;s us define the square root procedure which will call itself (recur) until our test returns true:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sqrt-iter</span> guess x)
  (<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
  guess
  (<span style="color:#a6e22e">sqrt-iter</span> (<span style="color:#a6e22e">improve</span> guess x)
    x)))

</code></pre></div><p>The procedure <code>sqrt-iter</code> has two parameters: <code>guess</code> and <code>x</code>. <code>guess</code>
stands for the current guess and <code>x</code> for the number whose root we want
to find.</p>
<p>We fist check if the guess is accurate enough with the help of the
function <code>good-enough?</code> (defined later). If it is, we return guess.
Else, we call <code>sqrt-iter</code> again. However we pass the param <code>guess</code>
with the value of <code>(improve-guess guess x)</code> (function defined later)
and <code>x</code> as <code>x</code> itself..</p>
<p>This process of a function calling itself is called recursion.</p>
<h2 id="improving-a-guess">Improving a guess</h2>
<p>We next will define the procedure for improving a guess:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">improve-guess</span> guess x)
  (<span style="color:#a6e22e">average</span> guess (/ x guess))
</code></pre></div><p>Where average is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">average</span> x y)
  (/ (+ x y) <span style="color:#ae81ff">2</span>))
</code></pre></div><p>In <code>improve-guess</code>, the guess (<code>guess</code>) is averaged by guess divided by the
number whose root we want to find (<code>x</code>).</p>
<h2 id="checking-the-accuracy-of-a-guess">Checking the Accuracy of a guess</h2>
<p>We now have to define a test <code>good-enough</code> that will
check if the guess is accurate enough. One such way
is to check the difference between the square of the
current guess and <code>x</code> . Let&rsquo;s make that into scheme
code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
 (&lt; (abs (- (<span style="color:#a6e22e">square</span> guess) x)) <span style="color:#ae81ff">0.0001</span>))
</code></pre></div><p>Here we take the absolute value of the difference of the square guess and x and
compare it with 0.0001. If it the difference is smaller, <code>#t</code> is returned.
<code>#t</code> is Scheme for the Boolean <code>True</code>. Else <code>#f</code> which is <code>False</code>.</p>
<h2 id="writing-the-wrapper-procedure">Writing the wrapper procedure</h2>
<p>When we want to find to square root, we don&rsquo;t want to supply
<code>sqr-iter</code> with a guess. Instead, we will write a function that
will call <code>sqrt-iter</code> with a default guess. Usually, this standard
guess is one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">square-root</span>  x)
  (<span style="color:#a6e22e">sqrt-iter</span> <span style="color:#ae81ff">1.0</span> x))
</code></pre></div><p><strong>Note:</strong> Notice how we pass 1.0 instead of 1
to sqrt-iter. This so that 1, when divided doesn&rsquo;t
become a rational no. (fraction)</p>
<h1 id="the-entire-script">The Entire Script</h1>
<p>We can now combine these functions to form a <code>.scm</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scheme" data-lang="scheme">(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">average</span> x y)
  (/ (+ x y) <span style="color:#ae81ff">2</span>)) <span style="color:#75715e">;; divide the sum of x and y by 2</span>


(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">improve-guess</span> guess x)
  (<span style="color:#a6e22e">average</span> guess (/ x guess)))<span style="color:#75715e">;; return the average of guess and guess divided by x</span>

(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">square</span> x)
  (* x x))<span style="color:#75715e">;; returns the square of a numeral</span>

(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
  (&lt; (abs (- (<span style="color:#a6e22e">square</span> guess) x)) <span style="color:#ae81ff">0.0001</span>))<span style="color:#75715e">;; compare the guess&#39;s square and x</span>


(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sqrt-iter</span> guess x)
  (<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
      guess
      (<span style="color:#a6e22e">sqrt-iter</span> (<span style="color:#a6e22e">improve-guess</span> guess x)
                 x)))
  <span style="color:#75715e">;; if our guess is good enough, return it,</span>
  <span style="color:#75715e">;;else call (sqrt-iter) with an improved guess</span>


(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">square-root</span> x)
  (<span style="color:#a6e22e">sqrt-iter</span> <span style="color:#ae81ff">1.0</span> x)) <span style="color:#75715e">;; Call sqrt-iter with the guess of 1</span>

</code></pre></div><h1 id="running-our-program">Running our program</h1>
<p>Now notice that our <code>good-enough?</code> procedure will check if the
difference between the square of guess and x is 0.0001.
This is okay for normal size number but isn&rsquo;t accurate enough for
Larger numbers and small numbers. Hence, some leniency is required.</p>
<p>Running this on MIT/GNU Scheme:</p>
<pre><code>1 ]=&gt; (square-root 4)

;Value: 2.0000000929222947

</code></pre><p>Of course this isn&rsquo;t correct but an approximate answer.
If we square our square root we get:</p>
<pre><code>1 ]=&gt; (square (square-root 4))

;Value: 4.000000371689188
</code></pre><p>Which shouldn&rsquo;t be the Answer. However, this is only off by
from the 6th decimal point.</p>
<p>If you try to find the square root of
0.0005, you will get:</p>
<pre><code>1 ]=&gt; (square-root 0.005)

;Value: 2.25070568342295233-2
</code></pre><p>And when we square the root:</p>
<pre><code>1 ]=&gt; (square (square-root 0.0005))
;Value: 5.065676073392379e-4
</code></pre><p>Which is utter bull considering the level of accuracy we gave.
(We had given <code>0.0005</code> and not <code>0.0005065676073392379</code>)</p>
<p>Similarly for <code>1234567890987654321234567890</code>:</p>
<pre><code>1 ]=&gt; (square-root 1234567890987654321234567890)
...
</code></pre><p>Nothing. Which goes to say that our test is hopeless when computing small numbers
and larger numbers. This issue will be taken care of in <a href="https://benjamin-philip.github.io/sicp/sicp-ex-1-7">Ex 1.7.</a></p>

</div>


      </main>

      
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'G-8PFRPH4Y65', 'auto');
	
	ga('send', 'pageview');
}
</script>

      
  </body>
</html>
